DFS (Depth-First Search)
=
## What is
- 가장 깊은 노드까지 탐색
- 한 방향으로 쭉 파고듬
- 재귀 / 스택
- 경로 찾기, 모든 조합/경우 탐색

## Example Graph
```
graph:
0: [1, 2]
1: [3]
2: [4]
3: []
4: []

   0
  / \
 1   2
 |    \
 3     4


DFS(0)을 하면 순서: 0 → 1 → 3 → 2 → 4
```
- ``visited`` array 필요함
    - 방문했던 노드를 다시 방문하지 않도록 하기 위해 필요함
    - 없으면 무한루프에 빠질 수 있음.

## 작동 방식
```
dfs(0)
 └ dfs(1)
     └ dfs(3)
 └ dfs(2)
     └ dfs(4)
```
- 스택처럼 깊게 호출되고 끄탄면 되돌아오면서 다른 이웃으로 이동

## Time Complexity
- ``O(V + E)`` (V = nodes, E = edges)

BFS (Breadth-First Search)
=
## What is
- 가장 가까운 노드들 부터 탐색하는 방식
- 근처 이웃부터 넓게 탐색
- 큐
- 최단거리, 최소 단계 탐색
 
"시작점에서 가까운 노드들부터 탐색하고,
그 다음엔 그 노드들의 이웃들을 탐색한다."

## Example Graph
```
graph:
0: [1, 2]
1: [3]
2: [4]
3: []
4: []

   0
  / \
 1   2
 |    \
 3     4


BFS(0)의 순서: 0 → 1 → 2 → 3 → 4
```
- 핵심 자료구조: `queue`
    - 먼저 방문한 노드가 먼저 탐색됨 (선입선출)
    - 탐색할 노드를 queue에 넣고, 꺼내면서 이웃을 다시 넣음

## 작동 순서
🔍 작동 순서 (큐의 상태)
1. q = [0] → 출력 0
2. q = [1, 2] → 출력 1
3. q = [2, 3] → 출력 2
4. q = [3, 4] → 출력 3
5. q = [4] → 출력 4


# DFS vs BFS
| 특징    | DFS                | BFS                   |
| ----- | ------------------ | --------------------- |
| 방식    | 깊이 우선 (재귀 or 스택)   | 너비 우선 (큐)             |
| 사용 목적 | 경로 탐색, 백트래킹, 조합    | 최단 거리 탐색, 단계적 탐색      |
| 구조    | call stack / stack | queue                 |
| 메모리   | 깊이에 따라 stack 깊어짐   | 너비에 따라 queue 커짐       |
| 예시 문제 | 섬의 개수, 조합, 퍼즐      | 최단 거리, Level-order 탐색 |

