Decorator
==
## What is?
- 객체의 구조를 바꾸지 않고, **기능을 동적으로 추가**할 수 있는 패턴
- Class를 상속하지 않고도 새로운 기능을 확장할 수 있음

## 예시 상황
- 커피를 주문하는 시스템
- 기본 커피에 우유, 기럽, 휘핑크림 등을 동적으로 추가하고 싶다
- 각각의 추가는 독립적이고 조합 가능해야 한다

## 구성요소
| 구성 요소               | 설명                                 |
| ------------------- | ---------------------------------- |
| `Component`         | 기본 인터페이스 (ex. Coffee)              |
| `ConcreteComponent` | 기본 구현체 (ex. BasicCoffee)           |
| `Decorator`         | 기능을 확장할 수 있는 추상 클래스                |
| `ConcreteDecorator` | 실제 기능을 확장하는 클래스 (ex. Milk, Whip 등) |

Check [decorator.cpp](decorator.cpp)

## 핵심포인트
| 질문                      | 포인트                                   |
| ----------------------- | ------------------------------------- |
| Q: 왜 상속 대신 데코레이터를 써야 해? | 상속은 조합이 불가능. 데코레이터는 런타임에 조합 가능.       |
| Q: OCP 원칙에 어떻게 부합해?     | 기존 코드는 수정하지 않고, 새로운 클래스를 만들어 확장만 함    |
| Q: 언제 써야 하나?            | 기능을 조합하거나 추가해야 할 때, 그리고 다형성을 유지해야 할 때 |

## 실무예시
- UI 프레임워크: 버튼에 테두리, 아이콘, 툴팁을 동적으로 추가
- 스트리밍: InputStream에 Buffered, Compressed, Encrypted 데코레이터
- 로깅: 기본 서비스에 로그 데코레이터, 권한 체크 데코레이터